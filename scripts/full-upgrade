#!/bin/sh

# Author: Rick Balocca
# Date: 2007
# Description:

PATH=/opt/vyatta/bin:$PATH

usage()
{
cat <<EOF
$0 must be run with one of the following options:
  -h : Print help ( this help text )
  -k : Keep all packages not part of the target Vyatta version.
       Due to package dependencies some user added packages may not
        function properly.
  -i : The user will be prompted to answer all questions generated by
        packages during the upgrade.
EOF
}

prevent_start_on_install()
{
if [ -f /usr/sbin/policy-rc.d ]
 then
  # Save policy-rc.d file
  mv /usr/sbin/policy-rc.d /usr/sbin/policy-rc.d.orig
fi

# Create policy-rc.d file
cat > /usr/sbin/policy-rc.d << EOF
#!/bin/sh

echo
echo "PREVENT DAEMONS FROM STARTING DURING UPGRADE"

exit 101
EOF

chmod 0755 /usr/sbin/policy-rc.d
}

revert_to_default_policy()
{
if [ -f /usr/sbin/policy-rc.d.orig ]
 then
  # Restore policy-rc.d file
  mv /usr/sbin/policy-rc.d.orig /usr/sbin/policy-rc.d
 else
  # Remove policy-rc.d file
  rm -f /usr/sbin/policy-rc.d
fi
}

stop_parent_fullupgrade() {
 revert_to_default_policy
 # need to stop parent full-upgrade script if one exists
 array=(`ps ax | grep "/usr/bin/full-upgrade\|/opt/vyatta/bin/full-upgrade" \
	| grep -v grep | awk {'print $1'}`)
 len=${#array[*]}
 i=0
 while [ $i -lt $len ]; do
  if [ "${array[$i]}" != "$$" ]; then
   kill -9 ${array[$i]} > /dev/null 2>&1
  fi
 let i++
 done
}

# picked up from install-system script
get_response () {
  ldefault=$(echo "$1" | tr [:upper:] [:lower:])
  loptions=$(echo "$2" | tr [:upper:] [:lower:])

  # get the response from the user
  read myresponse
  myresponse=$(echo "$myresponse" | tr [:upper:] [:lower:])

  # Check to see if the user accepts the default
  if [ -z "$myresponse" ]; then
    echo -n $ldefault
  # if we are passing in options to check, make sure response is a valid option
  elif [ -n "$loptions" ]; then
    for token in $loptions
      do
        if [ "$token" == "$myresponse" ]; then
          echo -n "$myresponse"
          return 0
        fi
      done
    return 1
  else
    echo -n "$myresponse"
  fi

  return 0
}

check_repo() {

# check if you have more than one repo configured in sources.list
# if yes, advise user and ask if user wishes to continue?
num_repos=`cat /etc/apt/sources.list | awk {'print $1'} | grep "^deb$" | wc -l`
if [ "$num_repos" == "0" ]; then
 echo No repository configured to retrieve packages
 exit 1
fi

if [ "$num_repos" -gt "1" ]; then
 response=''
 while [ -z "$response" ]
  do
   echo "full-upgrade process detected multiple repositories to get packages from"
   echo "unless specified in release notes, this is advised against during full-upgrade"
   echo -ne "Would you like to continue anyway? (Y/N) [N]: "
   response=$(get_response "N" "Y N")
   if [ "$response" == "n" ]; then
    exit 0
   fi
  done
fi

# simulate apt-get update and report error if any
apt-get --simulate update >/dev/null 2>&1
if [ `echo $?` != 0 ]; then
 echo "username/password incorrect or repository not configured accurately"
 exit 1
else
 apt-get --simulate update >/tmp/$$-sim-apt-update 2>&1
 count_failed=`grep -i 'FAILED' /tmp/$$-sim-apt-update | wc -l`
 if [ "$count_failed" != "0" ]; then
  echo "unable to resolve repository url or connect to repository"
  rm -f /tmp/$$-sim-apt-update
  exit 1
 fi
fi
}

trap stop_parent_fullupgrade INT TERM EXIT

if [ `whoami` != 'root' ] ; then
    echo "full-upgrade must be run with root privileges."
    exit 1
fi

check_repo
cd /tmp
prevent_start_on_install
check-upgrade $*

OPTION="$1"
[ "$OPTION" ] || OPTION=`ps l|grep -v grep|grep 'full-upgrade -'|sed 's,.*full-upgrade ,,'`
case "$OPTION" in
 -i )
	download-only "$OPTION" || exit $?
	/opt/vyatta/bin/_full-upgrade $OPTION
	;;

 -k )
	echo ===full-upgrade "$OPTION"===
	uptime
	date
	download-only "$OPTION" || exit $?
	if ! mkdir full-upgrade.lock
	then
		echo "full-upgrade can't acquire it's lock file (/tmp/full-upgrade.lock )."
		echo "You may be attempting to run full-upgrade more than once simultaneously."
		echo "If you want to proceed, then first rm -rf /tmp/full-upgrade.lock ."
		exit 1
	fi
	echo "Please wait.  Now entering unattended mode."
	echo "This will take a long time.  When done,"
	echo "the system will automatically reboot."
	hupfile=/root/nohup$$.out
	mkdir bak-$$
	mv /root/full-upgrade* bak-$$/.
	>/root/full-upgrade.log
	tail -f /root/full-upgrade.log&
	nohup /opt/vyatta/bin/_full-upgrade $OPTION>&$hupfile
	sleep 10
	cat /root/nohup$$.out
	rm -rf /tmp/full-upgrade.lock
	;;

 * )
	usage
	exit 1
esac
